---
phase: 07-quality-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/ErrorBoundary.jsx
  - main.jsx
  - egg-calculator.jsx
  - components/LocationPressure.jsx
autonomous: true

must_haves:
  truths:
    - "App continues running after a component rendering error (no white screen)"
    - "ConfigDialog error is isolated — rest of app remains interactive"
    - "TimerOverlay error is isolated — rest of app remains interactive"
    - "Pressure input cannot produce values outside physics-valid range"
  artifacts:
    - path: "components/ErrorBoundary.jsx"
      provides: "Reusable error boundary class component"
      contains: "getDerivedStateFromError"
      min_lines: 20
    - path: "main.jsx"
      provides: "Root-level error boundary wrapping EggCalculator"
      contains: "ErrorBoundary"
    - path: "egg-calculator.jsx"
      provides: "Section-level error boundaries around ConfigDialog and TimerOverlay"
      contains: "ErrorBoundary"
    - path: "components/LocationPressure.jsx"
      provides: "Silent clamping on pressure number input"
      contains: "Math.max"
  key_links:
    - from: "main.jsx"
      to: "components/ErrorBoundary.jsx"
      via: "import and wrap"
      pattern: "import.*ErrorBoundary"
    - from: "egg-calculator.jsx"
      to: "components/ErrorBoundary.jsx"
      via: "import and wrap ConfigDialog + TimerOverlay"
      pattern: "ErrorBoundary"
    - from: "components/LocationPressure.jsx"
      to: "physics calculations"
      via: "clamped pressure value"
      pattern: "Math\\.(max|min)"
---

<objective>
Add error boundaries at 3 strategic locations (app root, ConfigDialog, TimerOverlay) and silent input clamping on the pressure number input — the only text-entry numeric input in the app.

Purpose: Prevent white-screen crashes from rendering errors and ensure physics calculations never receive out-of-range pressure values.
Output: ErrorBoundary.jsx component, updated main.jsx and egg-calculator.jsx with boundary wrappers, updated LocationPressure.jsx with clamped onChange.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-quality-polish/07-RESEARCH.md

@main.jsx
@egg-calculator.jsx
@components/LocationPressure.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorBoundary component and wrap 3 major sections</name>
  <files>
    components/ErrorBoundary.jsx
    main.jsx
    egg-calculator.jsx
  </files>
  <action>
    Create `components/ErrorBoundary.jsx` as a React class component:
    - Constructor initializes `this.state = { hasError: false }`
    - `static getDerivedStateFromError(error)` returns `{ hasError: true }`
    - `componentDidCatch(error, info)` logs to console.error with error and info.componentStack
    - `render()` returns `this.props.fallback` if hasError, otherwise `this.props.children`
    - Default fallback (when no fallback prop): a styled div with amber/orange theme matching the app, showing a generic "Something went wrong" message in a rounded card
    - Export as named export: `export class ErrorBoundary extends React.Component`

    Update `main.jsx`:
    - Import ErrorBoundary from './components/ErrorBoundary'
    - Wrap `<EggCalculator />` inside `<ErrorBoundary>` (root boundary, uses default fallback)
    - Keep React.StrictMode as the outermost wrapper

    Update `egg-calculator.jsx`:
    - Import ErrorBoundary from './components/ErrorBoundary'
    - Wrap the ConfigDialog JSX (lines 193-207) in `<ErrorBoundary fallback={<div className="p-4 text-sm text-gray-500 text-center">{t('configDialogTitle')} unavailable</div>}>...</ErrorBoundary>`
    - Wrap the TimerOverlay conditional block (lines 210-221) in `<ErrorBoundary fallback={<div className="fixed inset-0 z-50 flex items-center justify-center"><div className="p-6 bg-white rounded-2xl shadow-xl text-center"><p className="text-gray-700">Timer unavailable</p><button onClick={stopTimer} className="mt-4 px-4 py-2 bg-amber-500 text-white rounded-lg">Close</button></div></div>}>...</ErrorBoundary>`

    Do NOT wrap every component — only these 3 boundaries (root, config dialog, timer overlay) matching the "major sections" requirement.
  </action>
  <verify>
    1. `npm run build` succeeds without errors
    2. `grep -r "getDerivedStateFromError" components/ErrorBoundary.jsx` finds the static method
    3. `grep -r "ErrorBoundary" main.jsx` confirms root boundary
    4. `grep -c "ErrorBoundary" egg-calculator.jsx` returns at least 3 (import + 2 wrappings)
  </verify>
  <done>
    - ErrorBoundary.jsx exists as class component with getDerivedStateFromError + componentDidCatch
    - main.jsx wraps EggCalculator in root ErrorBoundary
    - egg-calculator.jsx wraps ConfigDialog and TimerOverlay in section ErrorBoundaries with contextual fallbacks
    - Build passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Add silent clamping to pressure number input</name>
  <files>components/LocationPressure.jsx</files>
  <action>
    The pressure input in LocationPressure.jsx (line 63-68) is the ONLY text-entry number input in the app. All other numeric inputs are range sliders which already enforce bounds via HTML min/max attributes.

    Update the pressure input onChange handler to clamp values:
    - Valid pressure range: 870 hPa (extreme low, ~1400m hurricane) to 1084 hPa (record high)
    - Allow empty string while user is typing (don't clamp mid-edit)
    - On blur, if empty, reset to 1013.25 (standard atmosphere)
    - On onChange: if value is a valid number, clamp with Math.max(870, Math.min(1084, val)) before calling onPressureChange

    Implementation:
    ```jsx
    <input
      type="number"
      min="870"
      max="1084"
      value={pressure}
      onChange={(e) => {
        const val = Number(e.target.value);
        if (!isNaN(val)) {
          onPressureChange(Math.max(870, Math.min(1084, val)));
        }
      }}
      onBlur={(e) => {
        if (e.target.value === '' || isNaN(Number(e.target.value))) {
          onPressureChange(1013.25);
        }
      }}
      className="w-full px-2 py-2 text-base min-h-[44px] border border-sky-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-sky-400"
    />
    ```

    Do NOT add validation to range inputs — they already enforce bounds via HTML attributes and browser behavior. The research confirms "Range inputs (sliders) already enforce bounds via HTML attributes -- no extra JS clamping needed."
  </action>
  <verify>
    1. `npm run build` succeeds
    2. `grep "Math.max" components/LocationPressure.jsx` confirms clamping is present
    3. `grep "onBlur" components/LocationPressure.jsx` confirms blur handler exists
  </verify>
  <done>
    - Pressure number input silently clamps values to 870-1084 hPa range
    - Empty/invalid input resets to 1013.25 on blur
    - No error messages shown to user (silent clamping per user decision)
    - No changes to any range inputs
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes without errors or warnings
2. `npm test` passes (existing tests still work)
3. ErrorBoundary component exists with correct lifecycle methods
4. 3 error boundaries placed: root (main.jsx), ConfigDialog, TimerOverlay
5. Pressure input has onChange clamping and onBlur reset
6. No other inputs modified (range sliders untouched)
</verification>

<success_criteria>
- Error boundaries wrap 3 major sections (app root, ConfigDialog, TimerOverlay)
- A rendering error in ConfigDialog shows fallback UI, rest of app works
- A rendering error in TimerOverlay shows fallback UI, rest of app works
- Pressure input cannot produce values outside 870-1084 hPa
- Empty pressure input resets to standard atmosphere on blur
- All existing tests pass
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/07-quality-polish/07-01-SUMMARY.md`
</output>
