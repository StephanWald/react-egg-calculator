---
phase: 02-physics-validation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - test/physics.test.js
autonomous: true

must_haves:
  truths:
    - "Williams formula calculation has 10+ test cases with known-good outputs"
    - "Boiling point from pressure calculation tested across altitude range (0-3000m)"
    - "Pressure from boiling point calculation tested with inverse verification"
    - "Altitude from pressure calculation tested against barometric formula"
    - "Energy consumption calculation tested with all heating components"
    - "All tests pass"
  artifacts:
    - path: "test/physics.test.js"
      provides: "Comprehensive physics unit tests"
      min_lines: 200
  key_links:
    - from: "test/physics.test.js"
      to: "physics.js"
      via: "ES module import"
      pattern: "import.*from.*physics"
---

<objective>
Write comprehensive unit tests for all extracted physics functions in physics.js, achieving thorough coverage of the physics calculations.

Purpose: These tests prove the thermodynamic calculations are correct before any further refactoring. They serve as a regression safety net -- if any future change breaks physics, tests catch it immediately. This is the core value of the project: accurate egg cooking times.

Output: A test file `test/physics.test.js` with 30+ test cases covering all four physics functions including edge cases, inverse round-trips, and known-good values.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-physics-validation/02-RESEARCH.md
@.planning/phases/02-physics-validation/02-01-SUMMARY.md
@physics.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tests for pressure/boiling point/altitude functions</name>
  <files>test/physics.test.js</files>
  <action>
Create `test/physics.test.js` with comprehensive tests for the three atmospheric physics functions.

Import all functions:
```javascript
import { describe, it, expect } from 'vitest';
import {
  calculateBoilingPointFromPressure,
  calculatePressureFromBoilingPoint,
  calculateAltitudeFromPressure,
  calculateTime
} from '../physics';
```

**Section 1: calculateBoilingPointFromPressure**

Use `it.each` with table-driven tests. The formula is: `round((100 + 0.037 * (P - 1013.25)) * 10) / 10`

Test cases (compute expected values from the formula):
- 1013.25 hPa (sea level) -> 100.0 C
- 1050.0 hPa (below sea level, e.g. Dead Sea) -> 101.4 C
- 954.6 hPa (~500m altitude) -> 97.8 C
- 898.8 hPa (~1000m altitude) -> 95.8 C
- 845.6 hPa (~1500m altitude) -> 93.8 C
- 795.0 hPa (~2000m altitude) -> 91.9 C
- 701.2 hPa (~3000m altitude) -> 88.5 C
- 337.0 hPa (~Everest summit) -> 75.0 C

Also test edge cases:
- Very low pressure (300 hPa) -> should return a value below 75
- Very high pressure (1100 hPa) -> should return a value above 103

Use `toBeCloseTo(expected, 1)` for all comparisons (1 decimal place precision).

**Section 2: calculatePressureFromBoilingPoint**

Test cases (inverse of Section 1):
- 100.0 C -> 1013.3 hPa (note: rounding may cause slight difference from 1013.25)
- 95.0 C -> ~878.2 hPa
- 90.0 C -> ~743.2 hPa
- 80.0 C -> ~473.0 hPa

Also test:
- 100 C -> result should be close to 1013.25 (within 0.1)
- Inverse consistency: for each test case, verify that `calculateBoilingPointFromPressure(calculatePressureFromBoilingPoint(temp))` is close to `temp` (within 0.2 due to double rounding)

**Section 3: calculateAltitudeFromPressure**

Test cases using barometric formula: `round(44330 * (1 - pow(P / 1013.25, 0.1903)))`
- 1013.25 hPa -> 0 m (sea level)
- 954.6 hPa -> ~500 m
- 898.8 hPa -> ~1000 m
- 845.6 hPa -> ~1500 m
- 795.0 hPa -> ~2000 m
- 701.2 hPa -> ~3000 m

For altitude tests, use a tolerance of +/- 50m since these are approximations. Use `expect(result).toBeGreaterThanOrEqual(expected - 50)` and `expect(result).toBeLessThanOrEqual(expected + 50)` pattern, OR use `toBeCloseTo` with precision 0 (rounds to nearest 1, which means +/- 0.5 -- too tight). Better: just manually calculate exact expected outputs from the formula and use `toBe` since the formula uses `Math.round` to produce exact integers.

Actually, since the formula is deterministic with `Math.round`, compute the EXACT expected output:
- 1013.25 -> `Math.round(44330 * (1 - Math.pow(1013.25/1013.25, 0.1903)))` = 0
- 898.8 -> compute exact value and use `toBe`

Use a helper comment showing how each expected value was derived.

**Section 4: Inverse round-trip tests**

Test that pressure -> boiling point -> pressure is consistent:
```javascript
describe('Inverse function round-trips', () => {
  it.each([800, 900, 950, 1000, 1013.25, 1050])
    ('pressure %f hPa round-trips through boiling point', (originalPressure) => {
      const bp = calculateBoilingPointFromPressure(originalPressure);
      const recoveredPressure = calculatePressureFromBoilingPoint(bp);
      expect(recoveredPressure).toBeCloseTo(originalPressure, 0);
    });
});
```
Use precision 0 for round-trips (tolerance of +/- 0.5) since both functions apply `Math.round(...*10)/10`.

Also test boiling point -> pressure -> boiling point:
```javascript
it.each([85, 90, 95, 100, 105])
  ('boiling point %f C round-trips through pressure', (originalBP) => {
    const p = calculatePressureFromBoilingPoint(originalBP);
    const recoveredBP = calculateBoilingPointFromPressure(p);
    expect(recoveredBP).toBeCloseTo(originalBP, 0);
  });
```

All comparison notes:
- Use `toBeCloseTo(expected, 1)` for single-function results (temperature, pressure)
- Use `toBeCloseTo(expected, 0)` for round-trip results (compounded rounding)
- Use `toBe` for altitude results (formula produces exact integers via Math.round)
- NEVER use `toBe` for floating-point results from the pressure/temperature functions
  </action>
  <verify>
Run: `npx vitest run test/physics.test.js` -- all tests in sections 1-4 pass.
  </verify>
  <done>Tests for calculateBoilingPointFromPressure (8+ cases across 0-3000m altitude range), calculatePressureFromBoilingPoint (4+ cases + inverse verification), calculateAltitudeFromPressure (6+ cases against barometric formula), and round-trip tests (10+ cases) all pass.</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for Williams formula (calculateTime)</name>
  <files>test/physics.test.js</files>
  <action>
Add comprehensive tests for `calculateTime` to the same test file.

The `calculateTime` function accepts a params object and returns a result object (or null). Test it directly as a pure function.

**Section 5: calculateTime - Input validation**

Test that invalid inputs return null:
- weight = 0 -> null
- weight = -10 -> null
- boilingPoint <= targetTemp (e.g., boilingPoint=60, targetTemp=67) -> null
- targetTemp <= startTemp (e.g., targetTemp=4, startTemp=20) -> null

**Section 6: calculateTime - Default/baseline case**

Create a "default params" helper object that matches the component defaults:
```javascript
const defaultParams = {
  weight: 60,
  startTemp: 4,
  targetTemp: 67,
  boilingPoint: 100,
  eggCount: 1,
  waterVolume: 1.5,
  stovePower: 2000,
  stoveEfficiency: 0.87,
  potWeight: 0.8,
  potHeatCapacity: 0.50,  // steel
  waterStartTemp: 15,
  ambientTemp: 22
};
```

Test that the default case returns a valid result:
- result is not null
- result.cookingTime is a positive number (between 3 and 15 minutes for a medium egg)
- result.tempDrop is a positive number (water cools when eggs added)
- result.effectiveTemp is between startTemp and boilingPoint
- result.idealTime is a positive number and less than or equal to cookingTime
- result.totalEnergy is a positive number (reasonable range: 200-1000 kJ)
- result.heatingTime is a positive number

**Section 7: calculateTime - Williams formula behavior (10+ test cases)**

Use `it.each` to test that the formula behaves correctly across parameter variations. For each test, override one or two params from defaults.

Test physical relationships (these are behavior tests, not exact value tests):

1. **Heavier eggs take longer**: weight 50g vs 70g (same target) -> heavier has longer cookingTime
2. **Colder eggs take longer**: startTemp 4C vs 20C -> colder has longer cookingTime
3. **Higher target temp takes longer**: targetTemp 63C (soft) vs 77C (hard) -> higher target takes longer
4. **Lower boiling point increases time**: boilingPoint 95C vs 100C -> lower BP has longer cookingTime
5. **More eggs increase temp drop**: eggCount 1 vs 4 -> more eggs have larger tempDrop
6. **More water reduces temp drop**: waterVolume 0.5L vs 3.0L with 4 eggs -> more water has smaller tempDrop
7. **Higher stove power improves recovery**: stovePower 500W vs 3000W -> higher power has higher effectiveTemp
8. **Higher efficiency improves recovery**: stoveEfficiency 0.3 vs 0.87 -> higher efficiency has higher effectiveTemp
9. **Energy increases with more water**: waterVolume 0.5L vs 3.0L -> more water has higher totalEnergy
10. **Energy includes pot heating**: potWeight 0.3kg vs 3.0kg -> heavier pot has higher totalEnergy
11. **Cold ambient increases energy**: ambientTemp 0C vs 30C -> colder ambient has higher totalEnergy (more heat loss)
12. **Cooking time has minimum of 3 minutes**: Edge case where formula gives < 3, result.cookingTime >= 3 (line 471: `Math.max(3, t_real)`)

For tests 1-11: Use comparison assertions (greaterThan / lessThan) not exact values. This tests physical correctness without depending on exact formula output.

**Section 8: calculateTime - Egg size variations**

Test all standard egg sizes with default params (but varying weight):
```javascript
it.each([
  { size: 'S', weight: 53 },
  { size: 'M', weight: 58 },
  { size: 'L', weight: 68 },
  { size: 'XL', weight: 78 },
])('$size egg ($weight g) produces valid cooking time', ({ weight }) => {
  const result = calculateTime({ ...defaultParams, weight });
  expect(result).not.toBeNull();
  expect(result.cookingTime).toBeGreaterThan(0);
  expect(result.cookingTime).toBeLessThan(20); // reasonable upper bound
});
```

**Section 9: calculateTime - Consistency/target temperature variations**

Test all consistency presets:
```javascript
it.each([
  { name: 'soft', targetTemp: 63 },
  { name: 'medium', targetTemp: 67 },
  { name: 'hard-medium', targetTemp: 72 },
  { name: 'hard', targetTemp: 77 },
])('$name consistency (target $targetTemp C) with default 60g egg', ({ targetTemp }) => {
  const result = calculateTime({ ...defaultParams, targetTemp });
  expect(result).not.toBeNull();
  expect(result.cookingTime).toBeGreaterThan(0);
});
```

And verify ordering: soft < medium < hard-medium < hard.

**Section 10: calculateTime - Energy calculation components**

Test that the energy calculation includes all components:
- Water heating dominates: compare totalEnergy with/without water heating contribution
- Pot heating adds to total: heavier pot = more energy
- Egg heating adds to total: more eggs = more energy (slight increase)
- Ambient loss adds to total: cold ambient = more energy

Also verify:
- heatingTime is proportional to water volume and inversely proportional to power
- heatingTime with 2x power -> approximately half the heatingTime
- totalEnergy divided by stoveEfficiency gives raw energy (test with efficiency=1.0 vs 0.5: latter should have ~2x totalEnergy)

**Section 11: calculateTime - Altitude/pressure effects**

Test that lower boiling points (high altitude) affect cooking:
```javascript
it.each([
  { altitude: 'sea level', boilingPoint: 100 },
  { altitude: '1000m', boilingPoint: 95.8 },
  { altitude: '2000m', boilingPoint: 91.9 },
  { altitude: '3000m', boilingPoint: 88.5 },
])('cooking at $altitude (BP=$boilingPoint C)', ({ boilingPoint }) => {
  const result = calculateTime({ ...defaultParams, boilingPoint });
  expect(result).not.toBeNull();
  expect(result.cookingTime).toBeGreaterThan(0);
});
```

Verify: lower boiling point = longer cooking time (physics: less thermal driving force).

**Test count goal:** At least 40+ individual test cases total across all sections. The Williams formula section (sections 6-11) should have at least 15 distinct test cases.

All floating-point comparisons use `toBeCloseTo` with appropriate precision or comparison operators (greaterThan, lessThan). NEVER use `toBe` for calculated floating-point values.
  </action>
  <verify>
Run: `npx vitest run test/physics.test.js` -- ALL tests pass.
Run: `npx vitest run test/physics.test.js --reporter=verbose` -- verify test count is 40+.
Run: `npm test` -- both the smoke test and physics tests pass.
  </verify>
  <done>test/physics.test.js contains 40+ test cases. Williams formula has 15+ test cases covering size variations, consistency presets, physical relationships, energy components, altitude effects, and edge cases. All atmospheric functions tested across altitude range 0-3000m with inverse round-trip verification. All tests pass. npm test passes for the full suite.</done>
</task>

<task type="auto">
  <name>Task 3: Verify coverage and run full suite</name>
  <files>test/physics.test.js</files>
  <action>
Run the full test suite with coverage and verify that physics.js has high coverage.

1. Run `npm run test:coverage` and check the output.
2. Verify physics.js has 100% statement, branch, function, and line coverage. If any branches are uncovered:
   - Identify which branch is missed (likely the null-return path or an edge case)
   - Add a targeted test case to cover it
   - Re-run coverage to confirm 100%

3. If coverage is not 100%, add the minimum test cases needed to reach it. Common missed branches:
   - The `weight > 0 && boilingPoint > targetTemp && targetTemp > startTemp` check -- make sure at least one test triggers each condition individually
   - The `Math.max(3, t_real)` minimum time clamp -- test a scenario where t_real < 3 (this is hard: it would need very small egg, high temp, etc.)
   - The `Math.max(0, t_ideal)` and `Math.max(0, t_real)` clamps

4. Final verification: `npm test` -- complete suite passes with no failures.
  </action>
  <verify>
Run: `npm run test:coverage` -- physics.js shows 100% on statements, branches, functions, and lines.
Run: `npm test` -- all tests pass (0 failures).
  </verify>
  <done>physics.js has 100% coverage (statements, branches, functions, lines). Full test suite passes with 0 failures. Physics validation is complete.</done>
</task>

</tasks>

<verification>
1. `npm test` passes with all tests (smoke test + physics tests)
2. `npm run test:coverage` shows physics.js at 100% coverage
3. `npx vitest run test/physics.test.js --reporter=verbose` shows 40+ test cases
4. Williams formula has 15+ test cases (size, consistency, physical relationships, energy, altitude, edge cases)
5. Boiling point from pressure tested across 8+ altitude data points
6. Inverse round-trip tests verify pressure <-> boiling point consistency
7. Altitude from pressure tested against barometric formula at 6+ data points
</verification>

<success_criteria>
- Williams formula calculation has 10+ test cases with known-good outputs (Phase SC #1)
- Boiling point from pressure calculation tested across altitude range 0-3000m (Phase SC #2)
- Pressure from boiling point calculation tested with inverse verification (Phase SC #3)
- Altitude from pressure calculation tested against barometric formula (Phase SC #4)
- Energy consumption calculation tested with all heating components (Phase SC #5)
- All tests pass at 100% coverage for physics functions (Phase SC #6)
</success_criteria>

<output>
After completion, create `.planning/phases/02-physics-validation/02-02-SUMMARY.md`
</output>
