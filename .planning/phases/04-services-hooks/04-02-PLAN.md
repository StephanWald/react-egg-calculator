---
phase: 04-services-hooks
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - hooks/useTimerLogic.js
  - hooks/useLocationPressure.js
  - test/hooks/useTimerLogic.test.js
  - test/hooks/useLocationPressure.test.js
autonomous: true

must_haves:
  truths:
    - "Timer starts countdown from given seconds, decrements each second"
    - "Timer pauses and resumes without losing position"
    - "Timer completion triggers notification, vibration, and audio side effects"
    - "Location hook fetches GPS coordinates, then pressure from Open-Meteo, then city from Nominatim"
    - "Location hook handles GPS permission denial and network errors gracefully"
    - "Manual pressure/boilingPoint entry recalculates related atmospheric values"
  artifacts:
    - path: "hooks/useTimerLogic.js"
      provides: "Timer countdown hook with side effects"
      exports: ["useTimerLogic"]
    - path: "hooks/useLocationPressure.js"
      provides: "GPS + pressure + geocoding hook"
      exports: ["useLocationPressure"]
    - path: "test/hooks/useTimerLogic.test.js"
      provides: "Timer hook tests with fake timers"
    - path: "test/hooks/useLocationPressure.test.js"
      provides: "Location/pressure hook tests with geolocation mock"
  key_links:
    - from: "hooks/useTimerLogic.js"
      to: "setInterval/clearInterval"
      via: "useEffect with timer"
      pattern: "setInterval.*1000"
    - from: "hooks/useTimerLogic.js"
      to: "Notification API"
      via: "new Notification on timer complete"
      pattern: "new Notification"
    - from: "hooks/useLocationPressure.js"
      to: "services/meteoApi.js"
      via: "import fetchSurfacePressure"
      pattern: "import.*fetchSurfacePressure.*meteoApi"
    - from: "hooks/useLocationPressure.js"
      to: "services/geocodingApi.js"
      via: "import fetchLocationName"
      pattern: "import.*fetchLocationName.*geocodingApi"
    - from: "hooks/useLocationPressure.js"
      to: "physics.js"
      via: "import atmospheric calculations"
      pattern: "import.*calculate.*(BoilingPoint|Pressure|Altitude).*physics"
---

<objective>
Create the complex hooks: useTimerLogic (timer countdown with browser side effects) and useLocationPressure (GPS + API integration for atmospheric data).

Purpose: Extract the two most complex stateful behaviors from the monolithic component. useTimerLogic owns all timer side effects (notifications, vibration, audio). useLocationPressure orchestrates the GPS -> Open-Meteo -> Nominatim flow using the services created in Plan 01.
Output: 2 hook modules with comprehensive tests covering timer mechanics, side effects, geolocation mocking, and error handling.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-services-hooks/04-CONTEXT.md
@.planning/phases/04-services-hooks/04-RESEARCH.md
@.planning/phases/04-services-hooks/04-01-SUMMARY.md

Source code to extract from:
@egg-calculator.jsx (lines 55-60 timer state, lines 173-227 timer effects, lines 408-496 timer handlers/audio, lines 32-39 location state, lines 289-374 location logic)
@services/meteoApi.js (fetchSurfacePressure - created in Plan 01)
@services/geocodingApi.js (fetchLocationName - created in Plan 01)
@physics.js (calculateBoilingPointFromPressure, calculatePressureFromBoilingPoint, calculateAltitudeFromPressure)
@useTranslation.js (hook pattern precedent)
@vite.config.js (test config)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTimerLogic hook with tests</name>
  <files>
    hooks/useTimerLogic.js
    test/hooks/useTimerLogic.test.js
  </files>
  <action>
    Extract timer countdown logic from egg-calculator.jsx into a self-contained hook that owns ALL side effects (notifications, vibration, audio).

    **hooks/useTimerLogic.js:**
    - Export `useTimerLogic()` hook
    - State: timerActive (false), timerPaused (false), timerRemaining (null), timerComplete (false), notificationPermission ('default')
    - Import useState, useEffect, useCallback, useRef from 'react'

    **Countdown effect** (from lines 174-192):
    - useEffect that runs when timerActive or timerPaused changes
    - Guard: if not active, or paused, or remaining null/<=0, return early
    - setInterval(1000) with functional setState: `prev => prev <= 1 ? (setTimerComplete(true), setTimerActive(false), playTimerSound(), 0) : prev - 1`
    - CRITICAL: Use functional state update to avoid stale closure (Pitfall 1 in research)
    - Cleanup: return `() => clearInterval(interval)` (Pitfall 2)

    **Completion notification effect** (from lines 195-227):
    - useEffect triggered by timerRemaining === 0 && !timerActive
    - Browser notification if permission === 'granted': `new Notification(...)` with tag 'egg-timer', requireInteraction true, auto-close after 10s
    - NOTE: The notification uses translated text in the component. Since hooks should be translation-agnostic (research Open Question 2), accept an optional `notificationOptions` parameter: `useTimerLogic({ notificationTitle, notificationBody })` with defaults of 'Egg Timer' and 'Your eggs are ready!'
    - Vibrate if supported: `navigator.vibrate([200, 100, 200, 100, 200])`
    - Audio fallback: play base64 wav data (copy from line 218)

    **playTimerSound function** (from lines 464-496):
    - Internal function using AudioContext (not exported)
    - Create oscillator beeps at 800, 900, 1000 Hz with 0.5s spacing
    - Wrap in try/catch for environments without Web Audio API

    **Notification permission check** (from lines 138-143):
    - useEffect on mount: if Notification exists and permission !== 'default', sync state

    **Exported handlers** (useCallback each):
    - `startTimer(durationSeconds)` -- sets remaining, active=true, paused=false, complete=false. Also requests notification permission if 'default' (from lines 410-428)
    - `stopTimer()` -- sets active=false, paused=false, remaining=null, complete=false
    - `pauseTimer()` -- if active and not paused, set paused=true
    - `resumeTimer()` -- if active and paused, set paused=false
    - `dismissComplete()` -- sets complete=false, remaining=null

    Return: `{ timerActive, timerPaused, timerRemaining, timerComplete, notificationPermission, startTimer, stopTimer, pauseTimer, resumeTimer, dismissComplete }`

    **test/hooks/useTimerLogic.test.js:**
    - Use `vi.useFakeTimers()` in beforeEach, `vi.useRealTimers()` in afterEach
    - Mock browser APIs in beforeEach (from research examples):
      - `global.Notification = vi.fn()` with static `.permission = 'default'` and `.requestPermission = vi.fn().mockResolvedValue('granted')`
      - `global.AudioContext = vi.fn()` returning mock with createOscillator/createGain (from research Pattern 4)
      - `navigator.vibrate = vi.fn()` (may need vi.stubGlobal or Object.defineProperty)
    - `vi.restoreAllMocks()` in afterEach

    Test cases:
    1. Starts with inactive timer (timerActive false, timerRemaining null)
    2. startTimer(300) sets active=true, remaining=300
    3. Counts down by 1 each second (use `vi.advanceTimersByTimeAsync(1000)`)
    4. Completes when reaching zero (timerComplete=true, timerActive=false)
    5. Pauses countdown (remaining unchanged during paused time)
    6. Resumes countdown after pause
    7. stopTimer resets all state
    8. dismissComplete clears complete state
    9. Triggers Notification on completion when permission granted
    10. Triggers navigator.vibrate on completion
    11. Does not throw when Notification/AudioContext not available
    12. Requests notification permission on first startTimer

    CRITICAL: Use `vi.advanceTimersByTimeAsync()` not `vi.advanceTimersByTime()` to avoid Promise/timer deadlock (Pitfall 3 in research). Wrap all timer advances in `await act(async () => { ... })`.
  </action>
  <verify>
    Run `npx vitest run test/hooks/useTimerLogic.test.js` and confirm all tests pass.
  </verify>
  <done>
    useTimerLogic hook manages full timer lifecycle (start/stop/pause/resume/complete) with side effects (notification, vibration, audio). All timer tests pass using fake timers with async advancement.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useLocationPressure hook with tests</name>
  <files>
    hooks/useLocationPressure.js
    test/hooks/useLocationPressure.test.js
  </files>
  <action>
    Extract location/pressure detection logic from egg-calculator.jsx into a hook that orchestrates GPS -> API -> state updates.

    **hooks/useLocationPressure.js:**
    - Export `useLocationPressure()` hook
    - Import from services created in Plan 01: `fetchSurfacePressure` from `'../services/meteoApi'`, `fetchLocationName` from `'../services/geocodingApi'`
    - Import from physics.js: `calculateBoilingPointFromPressure`, `calculatePressureFromBoilingPoint`, `calculateAltitudeFromPressure`
    - Import useState, useCallback from 'react'

    **State** (from lines 32-39):
    - altitude (0), pressure (1013.25), boilingPoint (100)
    - locationName (null), locationLoading (false), locationError (null), pressureSource ('default')

    **getLocationAndPressure** (from lines 291-358):
    - async function wrapped in useCallback
    - Sets loading=true, error=null
    - Gets GPS position via `navigator.geolocation.getCurrentPosition` wrapped in Promise (with enableHighAccuracy, timeout 10000)
    - Calls `fetchSurfacePressure(latitude, longitude)` from meteoApi service
    - Sets pressure (rounded to 1 decimal), calculates boilingPoint from pressure, sets pressureSource='gps'
    - Determines elevation: prefer GPS altitude if valid (> -100), else API elevation, else calculated from pressure
    - Calls `fetchLocationName(latitude, longitude)` from geocodingApi service (if returns city, set locationName)
    - Error handling: GPS error code 1 = 'PERMISSION_DENIED', code 2 = 'POSITION_UNAVAILABLE', else error.message or 'LOCATION_ERROR'
    - NOTE: Return error CODES not translated strings (research Open Question 2). The component will map codes to translated messages.
    - finally: set loading=false

    **handleManualPressure(p)** (from lines 360-366):
    - useCallback: sets pressure, recalculates boilingPoint and altitude from pressure, sets pressureSource='manual', locationName=null

    **handleManualBoilingPoint(bp)** (from lines 368-374):
    - useCallback: sets boilingPoint, recalculates pressure and altitude, sets pressureSource='manual', locationName=null

    Return: `{ altitude, pressure, boilingPoint, locationName, locationLoading, locationError, pressureSource, getLocationAndPressure, handleManualPressure, handleManualBoilingPoint, setAltitude, setPressure, setBoilingPoint, setLocationName, setPressureSource }`
    (Expose raw setters so useSettings can restore persisted values on mount in Plan 03 rewire)

    **test/hooks/useLocationPressure.test.js:**
    - Mock geolocation: `Object.defineProperty(navigator, 'geolocation', { value: { getCurrentPosition: vi.fn() }, configurable: true })`
    - Mock fetch: `vi.spyOn(global, 'fetch')`
    - Save/restore navigator.geolocation in beforeEach/afterEach (Pitfall 6)
    - vi.restoreAllMocks() in afterEach

    Test cases:
    1. Starts with default pressure values (1013.25 hPa, 100 C boiling, 0 m altitude)
    2. getLocationAndPressure fetches GPS -> sets pressure, boilingPoint, altitude, locationName
    3. Uses GPS altitude when valid (> -100)
    4. Falls back to API elevation when GPS altitude invalid
    5. Falls back to calculated altitude when both unavailable
    6. Handles GPS permission denied (error code 1) -- returns 'PERMISSION_DENIED' error
    7. Handles position unavailable (error code 2)
    8. Sets pressureSource to 'gps' after successful fetch
    9. Sets locationLoading true during fetch, false after
    10. handleManualPressure recalculates boilingPoint and altitude
    11. handleManualBoilingPoint recalculates pressure and altitude
    12. Manual entry sets pressureSource='manual' and clears locationName
    13. Geocoding failure does not affect pressure data (informational only)

    Mock pattern for GPS success:
    ```
    mockGeolocation.getCurrentPosition.mockImplementation((success) => {
      success({ coords: { latitude: 52.52, longitude: 13.405, altitude: 34 } });
    });
    ```

    Mock pattern for GPS error:
    ```
    mockGeolocation.getCurrentPosition.mockImplementation((_, error) => {
      error({ code: 1, message: 'User denied' });
    });
    ```

    Mock fetch to return different responses for Open-Meteo (first call) and Nominatim (second call) using mockResolvedValueOnce chaining.
  </action>
  <verify>
    Run `npx vitest run test/hooks/useLocationPressure.test.js` and confirm all tests pass.
  </verify>
  <done>
    useLocationPressure hook orchestrates GPS -> Open-Meteo -> Nominatim flow using service modules. Manual pressure/boilingPoint entry recalculates related values. Error codes returned (not translated strings). All location/pressure tests pass with geolocation and fetch mocks.
  </done>
</task>

</tasks>

<verification>
Run full test suite: `npx vitest run`
- All existing tests still pass
- All Plan 01 tests still pass (services + settings + unit-conversion)
- Timer tests pass with fake timers and async advancement
- Location tests pass with geolocation and fetch mocks
- No new dependencies installed
</verification>

<success_criteria>
- useTimerLogic manages full timer lifecycle with notification/vibration/audio side effects
- useLocationPressure orchestrates GPS -> API flow, imports from services/meteoApi and services/geocodingApi
- Both hooks independently testable via renderHook (no component mounting)
- Timer tests use vi.advanceTimersByTimeAsync (not sync variant)
- Location tests properly mock/restore navigator.geolocation between tests
- All tests pass including existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-services-hooks/04-02-SUMMARY.md`
</output>
